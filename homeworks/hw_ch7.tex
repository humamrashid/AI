% Homework, Chapter 7.
% Humam Rashid
% Spring 2020, CISC 7410X, Prof. Raphan

\documentclass{scrartcl}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}
\usepackage{listings}
\lstset {
    basicstyle=\ttfamily,
    mathescape
}
\begin{document}

\begin{flushleft}
Humam Rashid\\
Spring 2020, CISC 7410X, Prof. Raphan\\
\underline{Homework, Questions from Chapters 7,}\\
\textit{Artificial Intelligence: A Modern Approach}, 3rd Edition
\end{flushleft}

\section*{Chapter 7}
\textbf{7.2} Given the premise, we can deduce the following:
\begin{enumerate}
    \item The unicorn being mythical implies it is immortal.
    \item The unicorn not being mythical implies it is a mortal mammal.
    \item From the above two statements, the unicorn is either immortal or a mammal, there is no
        other possibility.
    \item In either case (being immortal or a mammal), the unicorn is horned, and since these two
        cases are the only possibilities, the unicorn is always horned.
    \item The unicorn being horned implies it is magical, and since the unicorn is always horned,
        the unicorn is always magical.
\end{enumerate}
We cannot deduce deduce from this premise whether the unicorn is mythical or not. We can however
deduce that in all $2^5$ models, the unicorn is horned and it is magical.
\bigskip
\\
\textbf{7.3}
\begin{enumerate}[(a)]
    \item Ruby-like pseudo-code for recursive function \verb|PL-TRUE?(s, m)|:
\begin{lstlisting}
PL-TRUE?(s, m):
    return s if s == True or s == False
    return LOOKUP(s, m) if SYMBOL?(s)
    case (s)
        when $\Rightarrow$:
            (not PL-TRUE?(s[0], m)) or PL-TRUE?(s[1], m)
        when $\Leftrightarrow$:
            PL-TRUE?(s[0], m) iff PL-TRUE?(s[1], m)
        when $\lor$:
            return (PL-TRUE?(s[0], m) or PL-TRUE?(s[1], m))
        when $\land$:
            return (PL-TRUE?(s[0], m) and PL-TRUE?(s[1], m))
        when $\neg$:
            return (not PL-TRUE?(s[0], m))
    end
end
\end{lstlisting}
        where \verb|s| is a literal, symbol or zero-indexed array of symbols and \verb|and|,
        \verb|or|, \verb|iff| are keyword constructs used in the language as in propositional logic.
    \item For the following examples, we assume $P$ and $Q$ to be symbols with unknown truth value:
        \begin{enumerate}[(i)]
            \item $True \lor P$, which always evaluates to $True$.
            \item $False \land P \land Q$, which always evaluates to $False$.
            \item $P \land \neg P$, which always evaluates to $False$.
        \end{enumerate}
    \item A general algorithm for partial models in propositional logic would need to evaluate empty
        models, i.e., models with no assignments. Thus, this algorithm would need to determine both
        validity and unsatisfiability, which are Co-$\mathcal{NP}$-Complete and
        $\mathcal{NP}$-Complete, respectively.
    \item A modified \verb|PL-TRUE?| algorithm which can determine truth values of some partial
        models can be the the same as the above given \verb|PL-TRUE?| with the additional feature of
        short-circuit evalutation for its \verb|and| and \verb|or| keyword operators similar to what
        is found in the Python programming language (or equivalently \verb|&&| and \verb:||: in
        C or Java). Some examples of partial models where this would \emph{not} work include (assume
        that the truth value of $P$ is unknown):
        \begin{enumerate}[(i)]
            \item $P \land \neg P$.
            \item $P \lor True$.
            \item $P \land False$.
        \end{enumerate}
    \item Short-circuit evaluation as described above allows for a significant speedup and is the
        design utilized in common programming languages today.
\end{enumerate}
\textbf{7.4}
\begin{enumerate}[(a)]
    \item $False \models True$: True.
    \item $True \models False$: False.
    \item $(A \land B) \models (A \Leftrightarrow B)$: True.
    \item $(A \Leftrightarrow B) \models (A \lor B)$: False.
    \item $(A \Leftrightarrow B) \models (\neg A \lor B)$: True.
    \item
    \item
    \item
    \item
    \item
    \item
    \item
\end{enumerate}
\textbf{7.5}\\
\textbf{7.6}\\
\textbf{7.12}

\end{document}

% EOF.
